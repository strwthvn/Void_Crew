# Best Practices: разработка игр на C++

## Философия разработки

### Итеративный подход

**Начинай с малого.** Первая версия любой системы должна быть минимальной и работающей. Сложность добавляется итеративно, когда простая версия доказала свою жизнеспособность. Это касается всего: от игрового цикла до сетевого протокола.

**Рефакторинг — норма, а не провал.** Код будет переписываться. Первое решение редко оказывается оптимальным, потому что понимание задачи приходит в процессе её решения. Планируй на изменения, не привязывайся к текущей реализации.

**Работающий прототип важнее идеального плана.** Теоретические рассуждения о лучшей архитектуре менее ценны, чем запущенный код, который можно потрогать и оценить. Прототипируй быстро, выбрасывай без сожалений.

### Простота как цель

**Избегай преждевременной оптимизации.** Сначала — корректность, потом — производительность. Оптимизируй только то, что измерено и доказано узким местом. Интуиция о производительности часто ошибочна.

**Избегай преждевременной абстракции.** Не создавай фреймворк для одного случая использования. Дождись, пока паттерн повторится трижды, прежде чем выделять общий код.

**Код, который не написан, не содержит багов.** Каждая строка — потенциальный источник ошибок и объект поддержки. Удаляй неиспользуемый код. Не пиши «на будущее».

---

## Архитектура игрового цикла

### Фиксированный шаг симуляции

**Почему это важно.** Переменный delta time кажется простым решением, но создаёт проблемы: нестабильная физика, невоспроизводимое поведение, разный геймплей на разном железе. Фиксированный шаг симуляции решает эти проблемы.

**Базовый паттерн.** Симуляция выполняется с постоянным интервалом (например, 1/60 секунды). Рендеринг — с максимально возможной частотой. Между ними — аккумулятор времени.

**Аккумуляторный цикл:**
1. Измерь реальное время с прошлого кадра
2. Добавь к аккумулятору
3. Пока аккумулятор >= dt: выполни шаг симуляции, вычти dt
4. Интерполируй для рендеринга на основе остатка в аккумуляторе
5. Рендер

**Защита от спирали смерти.** Если симуляция не успевает за реальным временем, аккумулятор растёт бесконечно. Ограничь максимальное количество шагов за кадр или максимальное значение аккумулятора.

### Детерминизм

**Воспроизводимость критична.** Если одна и та же последовательность ввода даёт разный результат, отладка превращается в кошмар. Детерминизм позволяет записывать и воспроизводить сессии, что бесценно для поиска багов.

**Источники недетерминизма:**
- Плавающая точка с разными настройками компилятора
- Порядок итерации по неупорядоченным контейнерам
- Зависимость от системного времени
- Многопоточность без строгой синхронизации
- Разные генераторы случайных чисел

**Решения:**
- Используй один и тот же seed для ГПСЧ на всех платформах
- Избегай unordered_map/set в игровой логике
- Не используй системное время внутри симуляции
- Симуляция — однопоточная или с детерминированной синхронизацией

---

## Entity Component System

### Принципы ECS

**Композиция вместо наследования.** Сущность — это не класс в иерархии, а комбинация компонентов. «Враг» — не подкласс «Персонажа», а сущность с компонентами Health, AI, Movement.

**Данные отдельно от логики.** Компоненты — только данные, без методов. Системы — только логика, без состояния. Это разделение даёт свободу в организации памяти и упрощает тестирование.

**Системы работают с выборками.** Система не знает о конкретных сущностях — она обрабатывает все сущности, у которых есть нужные компоненты. Это масштабируется и устраняет явные зависимости.

### Проектирование компонентов

**Компоненты должны быть маленькими и сфокусированными.** HealthComponent содержит здоровье, не инвентарь. Если компонент разрастается — это сигнал разбить его на несколько.

**Избегай указателей между компонентами.** Ссылки через ID сущности, не через указатели. Указатели инвалидируются при перемещении памяти, ID — нет.

**Теги — компоненты без данных.** «Враг», «Игрок», «Мёртв» — это просто маркеры для фильтрации, им не нужны поля.

### Проектирование систем

**Одна ответственность.** MovementSystem двигает, DamageSystem наносит урон, RenderSystem рендерит. Не смешивай.

**Порядок имеет значение.** Системы выполняются последовательно. InputSystem → MovementSystem → CollisionSystem → DamageSystem → RenderSystem. Документируй зависимости, контролируй порядок.

**Общение через компоненты, не через вызовы.** Система не вызывает другую систему напрямую. Она добавляет/изменяет компоненты, которые другая система обработает в свою очередь.

---

## Сетевая архитектура

### Авторитетный сервер

**Сервер — единственный источник истины.** Клиент отправляет намерения (ввод), сервер решает, что произошло. Клиент показывает результат. Никаких исключений.

**Не доверяй клиенту ничего.** Каждое сообщение от клиента — потенциальный чит или ошибка. Валидируй всё: позиции, скорости, время, индексы.

**Ограничивай информацию клиенту.** Клиент получает только то, что его персонаж может знать. Позиция врага за стеной — серверная тайна. Это и античит, и оптимизация трафика.

### Компенсация задержки

**Клиентское предсказание.** Клиент применяет ввод локально, не дожидаясь сервера. Когда приходит авторитетное состояние — коррекция. Без предсказания любое действие ощущается с задержкой.

**Серверная сверка.** Клиент помнит свои предсказанные состояния. Когда сервер подтверждает прошлое состояние, клиент пересимулирует от него до текущего момента.

**Интерполяция сущностей.** Другие игроки и объекты отображаются с небольшой задержкой, интерполируя между известными серверными состояниями. Это сглаживает сетевой jitter.

### Оптимизация трафика

**Дельта-компрессия.** Отправляй только изменения, не полное состояние. Если позиция не изменилась — не передавай её.

**Приоритизация обновлений.** Близкие и важные объекты обновляются чаще, далёкие и неважные — реже. Пропускная способность ограничена, распределяй её разумно.

**Группировка пакетов.** Много маленьких пакетов хуже, чем один большой. Собирай сообщения и отправляй батчами.

---

## Управление памятью

### RAII и владение

**Ресурс привязан к времени жизни объекта.** Конструктор захватывает, деструктор освобождает. Никаких ручных delete, никаких утечек.

**Один владелец — unique_ptr.** По умолчанию используй unique_ptr. Он выражает единоличное владение и автоматически освобождает память.

**Разделяемое владение — исключение.** shared_ptr нужен редко. Если он нужен — подумай, правильно ли спроектировано владение. Циклические ссылки — типичная проблема shared_ptr.

**Наблюдение без владения — сырой указатель или ссылка.** Если функция не владеет объектом, она получает указатель или ссылку, не умный указатель.

### Пользовательские аллокаторы

**Стандартный аллокатор не всегда оптимален.** malloc/new универсальны, но не оптимизированы под игровые паттерны. Частые аллокации мелких объектов — дорого.

**Типы пользовательских аллокаторов:**
- **Pool allocator** — для объектов одинакового размера (компоненты, частицы)
- **Stack allocator** — для временных данных с LIFO-порядком освобождения
- **Linear allocator** — для данных, которые освобождаются все сразу (per-frame)
- **Free list** — для объектов разного размера с частым выделением/освобождением

**Когда использовать.** Профилирование покажет, где стандартный аллокатор — узкое место. Не пиши аллокатор заранее «на всякий случай».

### Кэш-дружелюбность

**Память — это иерархия.** L1 кэш — 3 цикла, RAM — 100+ циклов. Промах кэша в 30+ раз дороже попадания. Оптимизация доступа к памяти важнее оптимизации вычислений.

**Локальность данных.** Храни вместе то, что используется вместе. Array of Structures (AoS) vs Structure of Arrays (SoA) — второе лучше для массовой обработки.

**Избегай разреженных структур.** Связные списки, деревья с узлами в куче — враги кэша. Массивы и хеш-таблицы с открытой адресацией — друзья.

**False sharing в многопоточности.** Если два потока пишут в соседние ячейки памяти (одна cache line), они мешают друг другу. Выравнивай данные потоков на границу cache line (64 байта).

---

## Отладка и профилирование

### Инструментирование

**Встраивай метрики с самого начала.** Добавить профилирование в готовый код труднее, чем писать с ним сразу. Макросы для замера времени функций, счётчики аллокаций, размеры очередей — всё это нужно видеть.

**Визуализируй внутреннее состояние.** Debug-рендер для коллизий, навигационной сетки, состояний AI. Когда видишь, что происходит внутри — баги находятся быстрее.

**Логируй осмысленно.** Не «function called», а «Player 3 took 25 damage from Entity 42, health now 75». Логи должны рассказывать историю.

### Воспроизводимость багов

**Записывай сессии.** Seed генератора + последовательность ввода + версия билда = воспроизводимая сессия. Краш через час игры можно воспроизвести за секунду.

**Детерминированные тесты.** Тесты не должны «иногда падать». Если тест нестабилен — это баг в тесте или в тестируемом коде, но не нормальная ситуация.

**Минимизируй репро-кейс.** Когда баг найден — сократи шаги воспроизведения до минимума. Короткий репро-кейс = быстрая отладка.

### Профилирование производительности

**Измеряй, не гадай.** Интуиция о производительности обманчива. Профилировщик покажет, где реально тратится время. Tracy, Superluminal, VTune — выбери инструмент и освой его.

**Профилируй релизные билды.** Debug-билд имеет другие характеристики. Оптимизации меняют картину. То, что медленно в Debug, может быть быстрым в Release и наоборот.

**Ищи алгоритмические проблемы, не микрооптимизации.** O(n²) в горячем пути — катастрофа, которую не исправить ассемблерными вставками. Сначала — правильный алгоритм.

---

## Тестирование

### Модульные тесты

**Тестируй логику, не реализацию.** Тест проверяет, что функция делает правильное, а не как она это делает. Изменение реализации не должно ломать тесты, если поведение сохранилось.

**Изолируй зависимости.** Тест DamageSystem не должен требовать настоящий RenderSystem. Моки и стабы позволяют тестировать компоненты изолированно.

**Быстрые тесты — частые тесты.** Если тесты выполняются минуту, их запускают раз в день. Если секунду — после каждого изменения. Стремись к секундам.

### Интеграционные тесты

**Тестируй взаимодействие систем.** Модульный тест проверяет DamageSystem. Интеграционный — что DamageSystem + HealthSystem + DeathSystem корректно убивают врага.

**Автоматизируй игровые сценарии.** Скрипт, который проходит уровень, проверяет больше, чем сотня юнит-тестов. Записанные сессии можно использовать как регрессионные тесты.

**Сетевые тесты.** Запусти сервер и несколько тестовых клиентов. Проверь синхронизацию, обработку дисконнектов, устойчивость к плохому соединению.

### Playtesting

**QA — не финальный этап, а непрерывный процесс.** Тестируй с первого работающего прототипа. Чем раньше найден баг, тем дешевле его исправить.

**Разные тестировщики — разные баги.** Опытный QA найдёт edge cases. Новый игрок — проблемы UX. Оба ценны.

**Баг-репорты должны быть actionable.** Шаги воспроизведения, ожидаемый результат, фактический результат, версия, платформа. Без этого баг-репорт — шум.

---

## Безопасность

### Защита от читов

**Архитектурная защита важнее детекции.** Если сервер не доверяет клиенту — большинство читов невозможны по дизайну. Античит-клиент — дополнение, не замена.

**Валидация на сервере.** Проверяй физическую возможность действия. Игрок не может двигаться быстрее максимальной скорости. Нельзя стрелять без оружия. Нельзя использовать предмет, которого нет в инвентаре.

**Rate limiting.** Ограничь частоту действий. Игрок не может стрелять 1000 раз в секунду, даже если клиент отправляет такие команды.

**Обфускация — не защита.** Скрытие протокола или логики клиента замедляет читеров, но не останавливает. Не полагайся на obscurity.

### Защита от инъекций

**Валидируй все входные данные.** Строки от клиента не должны содержать управляющих символов. Числа — в допустимых диапазонах. Индексы — в границах массивов.

**Не выполняй клиентский код.** Если протокол позволяет отправлять скрипты — это вектор атаки. Данные — да, код — нет.

**Логируй подозрительную активность.** Невалидные пакеты, слишком частые запросы, невозможные действия — всё это сигналы о попытке атаки или баге.

---

## Многопоточность

### Когда использовать

**Не по умолчанию.** Многопоточность добавляет сложность: гонки данных, deadlocks, сложная отладка. Используй только когда однопоточное решение недостаточно быстро.

**Изолируй параллелизм.** Чем меньше кода знает о потоках, тем лучше. Параллельные системы за чистыми интерфейсами, остальной код — последовательный.

**Игровая логика — однопоточная.** Основной игровой цикл проще держать однопоточным. Параллелизм — для тяжёлых изолированных задач: загрузка ресурсов, генерация мешей, AI-расчёты.

### Паттерны

**Job system.** Не создавай потоки для каждой задачи. Пул рабочих потоков + очередь задач. taskflow, std::async с политикой launch::async + deferred.

**Lock-free где возможно.** Мьютексы — источник contention. Атомарные операции, lock-free очереди (moodycamel::ConcurrentQueue) для передачи данных между потоками.

**Избегай shared mutable state.** Лучший способ избежать гонок — не иметь разделяемого изменяемого состояния. Каждый поток работает со своими данными, результаты объединяются.

### Отладка

**Thread Sanitizer.** Запускай с TSan в CI. Он находит гонки данных, которые не проявляются при обычном запуске.

**Детерминированное воспроизведение.** Многопоточный код сложно отлаживать. Режим с детерминированным исполнением (один поток, фиксированный порядок) помогает воспроизвести баги.

---

## Работа с внешними библиотеками

### Выбор библиотек

**Активная поддержка.** Библиотека без обновлений год — риск. Баги не фиксятся, новые платформы не поддерживаются.

**Разрешительная лицензия.** MIT, BSD, Apache 2.0, zlib — безопасны для коммерческого проекта. GPL — несовместима с проприетарным кодом. Проверяй лицензию до интеграции.

**Минимум зависимостей.** Библиотека, тянущая десяток других — потенциальный ад. Header-only или single-file библиотеки проще интегрировать.

**Понимай, что используешь.** Не используй библиотеку как чёрный ящик. Читай документацию, понимай ограничения, знай, что происходит внутри.

### Интеграция

**Изолируй зависимости.** Обёртки над внешними API. Если библиотека меняется или заменяется — меняется только обёртка, не весь код.

**Фиксируй версии.** Никаких «latest». Конкретная версия в системе сборки. Обновление — осознанное решение, не сюрприз.

**Собирай из исходников.** Если возможно — собирай библиотеку вместе с проектом. Это даёт контроль над настройками компиляции и упрощает отладку.

---

## Документация

### Код как документация

**Хорошие имена важнее комментариев.** `calculateDamageWithArmorReduction(baseDamage, armorValue)` понятнее, чем `calc(a, b) // calculates damage`.

**Типы выражают намерения.** `EntityId`, не `uint32_t`. `Seconds`, не `float`. Типизированные обёртки предотвращают ошибки и служат документацией.

**Тесты как примеры.** Хороший тест показывает, как использовать API. Это живая документация, которая не устаревает.

### Когда писать документацию

**Публичный API.** Всё, что используется другими модулями, должно быть задокументировано: параметры, возвращаемые значения, исключения, инварианты.

**Неочевидные решения.** Почему используется именно этот алгоритм? Почему это ограничение? Комментарий с объяснением сэкономит часы тому, кто будет разбираться позже (включая тебя через полгода).

**Архитектура.** Высокоуровневые документы о структуре системы. Как компоненты связаны, какой поток данных, какие инварианты поддерживаются.

---

## Процесс разработки

### Контроль версий

**Коммить часто, коммить атомарно.** Один коммит — одно логическое изменение. Если коммит «добавил фичу и поправил баг» — это два коммита.

**Осмысленные сообщения.** «fix» — бесполезно. «Fix crash when player dies with active buff» — полезно. Сообщение коммита — для будущего разработчика, ищущего причину бага.

**Не коммить сломанный код.** Каждый коммит в основную ветку должен компилироваться и проходить тесты. Сломанный main — заблокированная команда.

### Code Review

**Review — не формальность.** Это шанс найти баги до того, как они попадут в продукт, и способ распространения знаний в команде.

**Проверяй логику, не только стиль.** Автоформаттер проверит пробелы. Человек проверяет, правильно ли код решает задачу.

**Небольшие PR проще ревьюить.** 50 строк — внимательный ревью. 500 строк — беглый просмотр. 5000 строк — «looks good, approve».

### Continuous Integration

**Автоматическая сборка на каждый коммит.** Если код не компилируется на CI — он сломан, даже если работает локально.

**Тесты в CI.** Модульные, интеграционные, с санитайзерами. Падающий тест блокирует merge.

**Разные конфигурации.** Debug и Release. Разные платформы. Разные компиляторы. Баг, проявляющийся только на Linux с GCC — всё ещё баг.

---

## Специфика проекта: космический симулятор

### Симуляция атмосферы

**Дискретизация по отсекам.** Непрерывная симуляция газов дорогая. Отсеки как дискретные единицы с усреднёнными параметрами — разумный компромисс.

**Предрассчитанная топология.** Граф связей между отсеками (через двери, вентиляцию, пробоины) не меняется часто. Кэшируй его, пересчитывай при изменениях.

**Асинхронные обновления для некритичных отсеков.** Отсек без игроков можно обновлять реже. Приоритизируй вычислительные ресурсы.

### Медицинская система

**Модульность повреждений.** Тело как граф систем. Повреждение одного узла влияет на связанные. Это позволяет сложное поведение из простых правил.

**Пошаговые операции.** Хирургия — не одно действие, а цепочка. Каждый шаг валидируется отдельно. Это и геймплей, и защита от эксплойтов.

**Скрытые параметры.** Внутренние повреждения не видны без диагностики. Информационная асимметрия создаёт напряжение и требует кооперации.

### Ролевая асимметрия

**Разные интерфейсы — разные данные.** Механик видит схемы реактора. Врач — анатомию. Капитан — сводку. Сервер отправляет каждому только релевантную информацию.

**Принудительная кооперация.** Никто не может всё. Это дизайнерское решение, поддержанное архитектурой: знания и возможности распределены между ролями.

### Процедурная генерация

**Seed как идентификатор.** Сохраняй seed, не результат генерации. Это экономит память и гарантирует воспроизводимость.

**Модульность генераторов.** Генератор карты не должен знать о генераторе существ. Композиция независимых генераторов проще отладки монолитного.

**Тестируемость.** Генератор с фиксированным seed должен давать идентичный результат. Это позволяет регрессионные тесты на генерацию.

---

## Чеклист перед коммитом

**Компиляция:**
- [ ] Код компилируется без warnings на всех целевых платформах
- [ ] Код компилируется с максимальным уровнем предупреждений

**Качество:**
- [ ] Код соответствует соглашениям проекта
- [ ] Нет закомментированного кода
- [ ] Нет TODO без номера задачи
- [ ] Сложная логика прокомментирована

**Тесты:**
- [ ] Новый код покрыт тестами
- [ ] Все существующие тесты проходят
- [ ] Тесты с санитайзерами не находят проблем

**Производительность:**
- [ ] Нет очевидных проблем с производительностью
- [ ] Нет аллокаций в горячих путях
- [ ] Профилирование не показывает регрессий

**Безопасность (для серверного кода):**
- [ ] Все данные от клиента валидируются
- [ ] Нет раскрытия серверной информации клиенту

---

## Ресурсы для изучения

### Книги

- **Game Programming Patterns** (Robert Nystrom) — паттерны, специфичные для игр
- **Game Engine Architecture** (Jason Gregory) — архитектура игровых движков
- **Effective Modern C++** (Scott Meyers) — современный C++
- **Data-Oriented Design** (Richard Fabian) — data-oriented подход

### Статьи

- **Fix Your Timestep!** (Glenn Fiedler) — игровой цикл с фиксированным шагом
- **Client-Server Game Architecture** (Gabriel Gambetta) — сетевая архитектура игр
- **ECS FAQ** (Sander Mertens) — всё о ECS

### Выступления

- **Overwatch Gameplay Architecture and Netcode** (GDC) — ECS и сеть в AAA-проекте
- **Data-Oriented Design and C++** (CppCon) — data-oriented в C++
