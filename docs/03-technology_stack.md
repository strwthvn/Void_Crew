# Технологический стек: сервер и клиент

## Общие принципы выбора технологий

### Почему C++

**Производительность.** Симуляция атмосферы, физика декомпрессии, расчёт поведения существ — всё это требует предсказуемой производительности. C++ даёт контроль над памятью и позволяет оптимизировать горячие пути без оглядки на сборщик мусора.

**Экосистема.** Большинство игровых библиотек и движков написаны на C++ или имеют C++ API. Сетевые библиотеки, аудио-движки, системы сериализации — всё доступно без прослоек.

**Единый язык для сервера и клиента.** Общий код между сервером и клиентом — структуры данных, протоколы, утилиты — проще поддерживать на одном языке. Нет необходимости синхронизировать два разных стека.

**Кроссплатформенность.** Сервер может работать на Linux, клиент — на Windows, macOS, Linux. C++ компилируется под все целевые платформы с минимальными изменениями.

### Архитектурные ограничения

**Разделение кодовой базы.** Сервер и клиент — отдельные исполняемые файлы с общей библиотекой. Общий код выносится в статическую библиотеку, специфичный — в соответствующие модули.

**Никакой игровой логики на клиенте.** Клиент не включает код расчёта урона, поведения AI, правил крафта. Эти модули компилируются только в серверный бинарник.

**Минимальные зависимости.** Каждая внешняя библиотека — потенциальный источник проблем. Выбираются только необходимые, с активной поддержкой и разрешительной лицензией.

---

## Серверный стек

### Ядро сервера

**Игровой цикл.** Фиксированный тикрейт — 30 или 60 тиков в секунду в зависимости от требований к точности симуляции. Отдельный поток для сетевого ввода-вывода, отдельный — для игровой логики. Синхронизация через lock-free очереди команд.

**Entity Component System.** Архитектура ECS для игровых объектов. Сущности — просто идентификаторы. Компоненты — данные без логики. Системы — функции, обрабатывающие компоненты. Это даёт кэш-эффективность и простое распараллеливание.

**Менеджер состояния мира.** Централизованное хранилище всех игровых данных. Отвечает за консистентность, откат при необходимости, формирование снимков для клиентов. Поддерживает версионирование состояния для отладки и реплеев.

### Симуляция систем корабля

**Атмосферный симулятор.** Модуль расчёта газового состава по отсекам. Учитывает объём помещений, проходимость вентиляции, утечки через пробоины. Использует упрощённую модель диффузии — точность важнее физической корректности.

**Энергетическая сеть.** Граф распределения энергии: генераторы, потребители, коммутаторы. Расчёт нагрузки, приоритетов отключения, каскадных сбоев. Механик взаимодействует с этой системой через серверные команды.

**Система повреждений.** Отслеживание состояния каждого компонента корабля: износ, повреждения, температурный режим. Связь между системами — повреждённый реактор влияет на энергосеть, та — на жизнеобеспечение.

### Симуляция персонажей

**Медицинская модель.** Тело персонажа как набор связанных систем: органы, кровеносная система, нервная система. Каждая травма имеет локализацию, тяжесть, динамику развития. Отдельный модуль для хирургических операций с пошаговой валидацией действий.

**Система потребностей.** Голод, усталость, кислородное голодание, температурный стресс. Параметры изменяются со временем и влияют на эффективность действий. Связь с кулинарной системой — качество еды определяет восстановление.

**Инвентарь и экипировка.** Иерархическая система контейнеров: персонаж → одежда → карманы → предметы. Учёт веса, объёма, совместимости слотов. Скафандр как отдельная подсистема со своими ресурсами.

### Искусственный интеллект

**Поведение существ.** Конечные автоматы для базовых состояний: патруль, преследование, атака, отступление. Дерево поведения для сложных решений. Модульные модификаторы — способность существа определяет доступные действия.

**Навигация.** Навигационная сетка для интерьеров корабля. Динамическое обновление при изменении проходимости — закрытые двери, разрушенные коридоры. Поддержка трёхмерной навигации для существ, способных передвигаться по стенам и потолку.

**Восприятие.** Система органов чувств для AI: зрение с учётом освещённости и преград, слух с затуханием по расстоянию, обоняние для отслеживания раненых. Данные восприятия определяют реакцию существа.

### Процедурная генерация

**Генератор окружения.** Создание карт регионов, станций, заброшенных кораблей. Использует wave function collapse или подобные алгоритмы для связных структур. Seed сохраняется для воспроизводимости.

**Мутации существ.** Комбинаторная система модификаторов. Базовый тип существа + набор случайных или направленных мутаций. Модификаторы влияют на характеристики, поведение, внешний вид.

**Событийный генератор.** Выбор и параметризация событий на основе состояния игры. Учитывает напряжённость, ресурсы экипажа, прошедшее время, историю предыдущих событий. Интерфейс для вмешательства ГеймМастера.

### Сетевой слой сервера

**Протокол.** UDP для игровых данных — низкая задержка важнее гарантии доставки. TCP для критичных операций — подключение, сохранение, административные команды. Собственный слой надёжности поверх UDP для важных игровых событий.

**Сериализация.** Бинарный формат для компактности и скорости. Схема с версионированием для совместимости при обновлениях. Дельта-компрессия для снимков состояния — передаются только изменения.

**Управление подключениями.** Аутентификация игроков, управление сессиями, обработка переподключений. Очередь команд для каждого клиента с защитой от флуда. Мониторинг качества соединения.

**Формирование снимков.** Система области интересов (area of interest) — каждый клиент получает данные только о релевантных объектах. Приоритизация обновлений: критичные изменения немедленно, косметические — по возможности.

### Голосовая связь на сервере

**Обработка потоков.** Приём голосовых пакетов от клиентов, определение получателей на основе пространственной модели и состояния рации. Маршрутизация с минимальной задержкой.

**Модификация сигнала.** Применение эффектов к голосу: помехи рации, искажение от расстояния, эхо помещений. Параметры эффектов определяются игровым состоянием и передаются клиенту вместе с голосовыми данными.

**Имитация голосов.** Если существо способно имитировать голос, сервер подменяет метаданные голосового потока, указывая ложный источник. Клиент получателя не может отличить подделку от оригинала.

### Инструменты ГеймМастера

**Привилегированный протокол.** Расширенный набор команд для клиента ГМ: спавн сущностей, телепортация, изменение параметров, активация событий. Валидация на сервере — ГМ не может нарушить консистентность мира.

**Полный доступ к данным.** ГМ получает нефильтрованное состояние мира: позиции всех объектов, скрытые параметры, очередь событий. Отдельная система формирования снимков без ограничений области интересов.

**Система режиссуры.** Очередь запланированных событий с возможностью корректировки в реальном времени. ГМ видит, что произойдёт через несколько минут, и может вмешаться.

---

## Клиентский стек

### Рендеринг

**Графический API.** Vulkan как основной — кроссплатформенный, низкоуровневый, даёт полный контроль. OpenGL как запасной вариант для старого оборудования. Абстрактный слой рендеринга скрывает различия API.

**PSX-эстетика.** Специализированный пайплайн для характерного визуального стиля. Низкополигональные модели без сглаживания. Аффинное текстурирование через модификацию UV-координат в вершинном шейдере. Эмуляция ограниченной точности вершин. Постобработка: дизеринг, ограниченная палитра, scanlines опционально.

**Ограниченная дальность прорисовки.** Программный туман с жёсткой границей видимости. Объекты за пределами дистанции не рендерятся вообще. Это и эстетический приём, и оптимизация.

**Динамическое освещение.** Несмотря на стилизацию, освещение современное: точечные источники, тени от фонариков, мерцание аварийного света. Ограниченное количество источников для соответствия эстетике.

**Интерфейс.** Immediate mode GUI для игровых интерфейсов — терминалы, приборы, инвентарь. Отдельный слой для HUD с минимальным воздействием на производительность. Шрифты и элементы интерфейса читаемые, вопреки общей стилизации.

### Аудио

**Пространственный звук.** HRTF для позиционирования источников звука в наушниках. Окклюзия и обструкция — стены глушат звук, углы создают дифракцию. Реверберация зависит от размера и материала помещения.

**Звуковой дизайн корабля.** Многослойный эмбиент: базовый гул систем, характерные звуки отсеков, реакция на события. Плавные переходы между зонами. Изменение звукового ландшафта при повреждениях — тишина потерянного отсека страшнее любого рёва.

**Голосовая связь.** Захват с микрофона, кодирование (Opus), отправка на сервер. Воспроизведение входящих потоков с применением эффектов, полученных от сервера. Пространственное позиционирование голосов других игроков.

### Ввод

**Обработка устройств.** Поддержка клавиатуры, мыши, геймпадов. Абстрактный слой ввода: игровые действия вместо конкретных кнопок. Конфигурируемые привязки.

**Передача на сервер.** Ввод не применяется локально — отправляется на сервер как команды. Минимальная предобработка: фильтрация дребезга, нормализация значений аналоговых стиков.

**Предсказание движения.** Опциональное локальное предсказание для уменьшения ощущаемой задержки. Клиент предполагает результат действия и показывает его немедленно. При получении авторитетных данных от сервера — коррекция с плавной интерполяцией.

### Сетевой слой клиента

**Подключение к серверу.** Установка соединения, аутентификация, получение начального состояния мира. Обработка разрывов и переподключений без потери контекста.

**Приём снимков.** Десериализация состояния мира, применение дельта-обновлений. Буферизация для интерполяции — клиент рендерит состояние с небольшой задержкой, чтобы иметь запас для плавности.

**Интерполяция и экстраполяция.** Между снимками от сервера клиент интерполирует позиции объектов. При потере пакетов — экстраполяция на основе предыдущего движения. Визуальная коррекция при расхождении с авторитетными данными.

**Отправка команд.** Очередь исходящих команд с временными метками. Подтверждение получения для критичных действий. Повторная отправка при потере.

---

## Общий код

### Структуры данных

**Игровые сущности.** Определения компонентов ECS, используемые и сервером, и клиентом. Сервер работает с полным набором, клиент — с подмножеством для рендеринга.

**Сетевые сообщения.** Структуры протокола: команды от клиента, снимки от сервера, голосовые пакеты. Код сериализации и десериализации.

**Идентификаторы.** Типизированные ID для сущностей, игроков, отсеков. Общие для сервера и клиента, чтобы избежать путаницы при передаче.

### Утилиты

**Математика.** Векторы, матрицы, кватернионы. Геометрические примитивы для коллизий. Общий код, чтобы расчёты на сервере и визуализация на клиенте совпадали.

**Контейнеры.** Специализированные структуры данных: пространственные индексы, кольцевые буферы, lock-free очереди. Оптимизированы под игровые паттерны использования.

**Логирование.** Единая система логов для отладки. Сервер пишет подробно, клиент — критичные события. Формат позволяет сопоставлять логи обеих сторон по временным меткам.

### Конфигурация

**Определения данных.** Описания предметов, существ, рецептов, эффектов. Загружаются из файлов при старте. Сервер использует для логики, клиент — для отображения.

**Баланс и настройки.** Числовые параметры систем: скорость потери кислорода, урон оружия, время крафта. Хранятся отдельно от кода, легко модифицируются без перекомпиляции.

---

## Сборка и инструменты

### Система сборки

**CMake.** Кроссплатформенная генерация проектов. Отдельные цели для сервера, клиента, общей библиотеки. Поддержка различных компиляторов: MSVC на Windows, Clang/GCC на Linux и macOS.

**Зависимости.** Внешние библиотеки подключаются как подмодули или через пакетный менеджер (vcpkg, Conan). Фиксированные версии для воспроизводимости сборки.

**Конфигурации.** Debug с полной отладочной информацией и проверками. Release с оптимизациями. RelWithDebInfo для профилирования в условиях, близких к релизу.

### Инструменты разработки

**Редактор уровней.** Отдельное приложение для создания и редактирования карт, кораблей, станций. Экспорт в формат, понятный генератору и серверу.

**Отладчик сервера.** Визуализация состояния мира без полноценного рендеринга. Инспекция сущностей, наблюдение за AI, просмотр сетевого трафика.

**Профилировщик.** Интеграция с системными профилировщиками (Tracy, Superluminal). Метки для игровых подсистем, чтобы видеть, где тратится время.

### Тестирование

**Модульные тесты.** Изолированные тесты для игровых систем: медицина, атмосфера, AI. Запускаются при каждой сборке.

**Интеграционные тесты.** Сервер и тестовый клиент в одном процессе. Проверка сетевого протокола, синхронизации состояния, обработки краевых случаев.

**Нагрузочные тесты.** Симуляция множества клиентов для проверки производительности сервера. Поиск узких мест до выхода в продакшен.

---

## Внешние библиотеки

### Сеть

**ENet или GameNetworkingSockets.** Надёжная доставка поверх UDP, управление соединениями, шифрование. Выбор зависит от требований к функциональности и лицензии.

**Opus.** Кодек для голосовой связи. Низкая задержка, хорошее качество при малом битрейте, широкая поддержка.

### Графика

**Vulkan SDK.** Официальный SDK с заголовками, загрузчиком, валидационными слоями. Обязателен для разработки.

**SDL2 или GLFW.** Создание окна, обработка ввода, управление контекстом. SDL предпочтительнее для более широкой поддержки устройств ввода.

**stb_image.** Загрузка текстур из распространённых форматов. Однофайловая библиотека, легко встраивается.

### Аудио

**OpenAL Soft или miniaudio.** Кроссплатформенный аудио-вывод с поддержкой пространственного звука. miniaudio проще, OpenAL функциональнее.

**Steam Audio или Resonance Audio.** HRTF, окклюзия, реверберация. Добавляет реалистичное пространственное восприятие.

### Общие

**EnTT.** Быстрая реализация ECS. Header-only, активно развивается. Альтернатива — flecs для более богатого функционала.

**spdlog.** Быстрое логирование с поддержкой форматирования. На ранних фазах используется синхронный режим (_mt sinks) для простоты отладки; переход на асинхронный режим запланирован на фазу 2, когда появится сетевая нагрузка.

**nlohmann/json или simdjson.** Парсинг конфигурационных файлов. JSON читаем человеком, удобен для данных, не требующих максимальной компактности.

**FlatBuffers или Cap'n Proto.** Бинарная сериализация для сетевого протокола и сохранений. Быстрее JSON, компактнее, с поддержкой версионирования схемы.

---

## Платформенные особенности

### Windows

**Компилятор.** MSVC из Visual Studio. Альтернативно — Clang-cl для совместимости с кодовой базой на других платформах.

**Графика.** Vulkan основной, DirectX 11 как запасной вариант для совместимости со старым оборудованием.

**Распространение.** Исполняемый файл + DLL зависимостей. Установщик или архив для ручной установки.

### Linux

**Компилятор.** GCC или Clang. Оба поддерживаются, CI собирает обоими для раннего обнаружения проблем совместимости.

**Графика.** Vulkan через системный драйвер. OpenGL как fallback для систем без поддержки Vulkan.

**Сервер.** Может работать headless — без графической подсистемы. Минимальные зависимости для развёртывания на VPS.

### macOS

**Компилятор.** Apple Clang из Xcode.

**Графика.** MoltenVK — реализация Vulkan поверх Metal. Или нативный Metal через абстракцию рендеринга.

**Ограничения.** Нет поддержки некоторых Vulkan-расширений. Тестирование на реальном оборудовании обязательно.

---

## Производительность

### Целевые показатели

**Сервер.** Стабильные 30-60 тиков в секунду при полном экипаже и активных угрозах. Запас мощности для пиковых нагрузок — массовые разрушения, много существ.

**Клиент.** 60 FPS на среднем оборудовании. PSX-эстетика не требует мощной видеокарты — основная нагрузка на CPU для логики и сети.

### Оптимизации

**Серверные.** Пространственное разбиение для коллизий и запросов. Ленивые вычисления — не пересчитывать атмосферу, если ничего не изменилось. Профилирование каждой подсистемы.

**Клиентские.** Frustum culling — не рендерить невидимое. LOD отсутствует как концепция — низкополигональные модели и так просты. Оптимизация draw calls через батчинг.

**Сетевые.** Дельта-компрессия снимков. Приоритизация данных — важное идёт первым. Адаптация к качеству соединения — при высоком пинге реже обновления второстепенных объектов.
