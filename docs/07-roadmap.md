# Roadmap: разработка движка

## Обзор

Этот документ описывает путь от нуля до готового движка, на котором можно разрабатывать игру. Конечная точка — состояние, когда инфраструктура готова и команда может сосредоточиться на геймплее, контенте и балансе, не отвлекаясь на низкоуровневые технические задачи.

**Критерий готовности движка:** можно запустить сервер, подключить несколько клиентов, управлять персонажами в тестовой сцене, видеть друг друга, общаться голосом, взаимодействовать с объектами. Вся базовая инфраструктура работает и протестирована.

---

## Фаза 0: Подготовка инфраструктуры

**Цель:** настроить окружение разработки, систему сборки, CI/CD, базовую структуру проекта.

**Длительность:** 1-2 недели

### 0.1 Инициализация репозитория

- Создать репозиторий с .gitignore для C++
- Настроить структуру директорий: `/src`, `/include`, `/libs`, `/tests`, `/docs`, `/tools`
- Создать README с инструкциями по сборке
- Настроить шаблоны issues и PR

### 0.2 Система сборки

- Настроить CMake с разделением на цели: `server`, `client`, `common`, `tests`
- Добавить конфигурации Debug, Release, RelWithDebInfo
- Интегрировать vcpkg для управления зависимостями
- Создать vcpkg.json с начальным набором зависимостей
- Проверить сборку на Windows (MSVC) и Linux (GCC, Clang)

### 0.3 Непрерывная интеграция

- Настроить CI pipeline (GitHub Actions / GitLab CI)
- Автоматическая сборка при каждом push и PR
- Сборка на нескольких платформах и компиляторах
- Запуск тестов после успешной сборки
- Блокировка merge при неудачной сборке

### 0.4 Инструменты качества кода

- Интегрировать clang-format с конфигурацией проекта
- Интегрировать clang-tidy с выбранными проверками
- Настроить pre-commit hooks для форматирования
- Добавить сборку с AddressSanitizer и UBSan в CI

### 0.5 Зависимости

- Добавить и проверить сборку с EnTT
- Добавить и проверить сборку с spdlog
- Добавить и проверить сборку с GLM
- Добавить и проверить сборку с FlatBuffers
- Добавить и проверить сборку с Catch2

**Результат фазы:** проект собирается на всех целевых платформах, CI работает, базовые зависимости подключены.

---

## Фаза 1: Ядро сервера

**Цель:** создать минимальное работающее серверное ядро с игровым циклом и ECS.

**Длительность:** 3-4 недели

### 1.1 Базовая структура сервера

- Создать точку входа сервера (main)
- Реализовать парсинг аргументов командной строки (порт, конфигурация)
- Создать класс Server как центральную точку управления
- Реализовать graceful shutdown по сигналам (SIGINT, SIGTERM)
- Добавить загрузку конфигурации из файла

### 1.2 Система логирования

- Настроить spdlog с несколькими sink'ами (консоль, файл)
- Создать макросы логирования по уровням
- Добавить ротацию лог-файлов
- Реализовать контекстное логирование (тег подсистемы)
- Добавить временные метки с высоким разрешением

### 1.3 Игровой цикл

- Реализовать основной цикл с фиксированным тикрейтом
- Создать таймер высокого разрешения
- Реализовать аккумуляторный паттерн для фиксированного dt
- Добавить защиту от спирали смерти (максимум тиков за кадр)
- Реализовать метрики производительности цикла (время тика, загрузка)

### 1.4 Entity Component System

- Интегрировать EnTT в серверный код
- Создать базовую обёртку над registry для удобства использования
- Определить первые компоненты: Transform, Identifier, NetworkSync
- Создать менеджер сущностей с генерацией уникальных ID
- Реализовать простую систему обновления (движение по прямой)
- Написать тесты для создания/удаления сущностей и компонентов

### 1.5 Система обновления

- Определить порядок выполнения систем
- Создать менеджер систем с регистрацией и упорядочиванием
- Реализовать передачу delta time в системы
- Добавить возможность включения/отключения систем
- Реализовать профилирование времени каждой системы

### 1.6 Сериализация состояния

- Создать FlatBuffers-схемы для базовых компонентов
- Реализовать сериализацию Transform, Identifier
- Реализовать десериализацию для загрузки сохранений
- Создать снимок всего мира (полный snapshot)
- Написать тесты сериализации/десериализации

**Результат фазы:** сервер запускается, крутит игровой цикл, создаёт сущности, обновляет их состояние, может сохранить и загрузить состояние мира.

---

## Фаза 2: Сетевой слой сервера

**Цель:** сервер принимает подключения и обменивается данными с клиентами.

**Длительность:** 4-5 недель

### 2.1 Интеграция сетевой библиотеки

- Добавить GameNetworkingSockets в зависимости
- Создать обёртку для инициализации и shutdown
- Реализовать класс NetworkServer для приёма соединений
- Настроить прослушивание на заданном порту
- Обработать базовые события: подключение, отключение, ошибка

### 2.2 Управление соединениями

- Создать класс ClientConnection для представления клиента
- Реализовать хранение активных соединений
- Добавить тайм-аут неактивных соединений
- Реализовать корректное отключение клиента
- Добавить метрики: количество подключений, пинг

### 2.3 Протокол сообщений

- Определить FlatBuffers-схемы для сетевых сообщений
- Создать базовые типы сообщений: Handshake, Input, Snapshot, Event
- Реализовать обёртку сообщения с типом и payload
- Добавить версионирование протокола
- Реализовать фабрику для создания сообщений по типу

### 2.4 Приём и обработка сообщений

- Создать отдельный поток для сетевого I/O
- Реализовать lock-free очередь входящих сообщений
- Связать сетевой поток с игровым через очередь
- Реализовать обработчик входящих сообщений в игровом цикле
- Добавить защиту от флуда (rate limiting)

### 2.5 Отправка состояния клиентам

- Реализовать формирование снимка мира для клиента
- Создать систему области интересов (area of interest)
- Реализовать фильтрацию сущностей по релевантности для клиента
- Добавить приоритизацию обновлений (критичные vs косметические)
- Реализовать периодическую отправку снимков

### 2.6 Дельта-компрессия

- Хранить предыдущее отправленное состояние для каждого клиента
- Реализовать сравнение текущего и предыдущего состояния
- Формировать дельта-снимок с только изменёнными данными
- Добавить периодическую отправку полного снимка (keyframe)
- Обработать потерю пакетов — запрос полного снимка

### 2.7 Обработка ввода от клиентов

- Определить схему сообщений ввода (движение, действия)
- Реализовать очередь ввода для каждого клиента
- Обработать ввод в игровом цикле
- Добавить валидацию ввода (разумные значения)
- Связать ввод с сущностью игрока

### 2.8 Handshake и аутентификация

- Реализовать протокол рукопожатия при подключении
- Добавить проверку версии протокола
- Создать простую аутентификацию (имя игрока)
- Отправить начальное состояние мира после handshake
- Обработать ошибки аутентификации

**Результат фазы:** сервер принимает подключения, получает ввод от клиентов, отправляет им состояние мира. Можно подключить тестовый клиент и увидеть обмен данными.

---

## Фаза 3: Ядро клиента

**Цель:** создать минимальный клиент, способный подключиться к серверу.

**Длительность:** 3-4 недели

### 3.1 Базовая структура клиента

- Создать точку входа клиента (main)
- Реализовать парсинг аргументов (адрес сервера, имя игрока)
- Создать класс Client как центральную точку управления
- Реализовать состояния клиента: Disconnected, Connecting, Connected, Playing
- Добавить graceful shutdown

### 3.2 Создание окна

- Интегрировать SDL2 для создания окна
- Реализовать создание окна с заданным разрешением
- Обработать события окна (закрытие, изменение размера, фокус)
- Добавить полноэкранный режим
- Реализовать клиентский цикл с обработкой событий

### 3.3 Сетевой слой клиента

- Создать класс NetworkClient для подключения к серверу
- Реализовать установку соединения по адресу
- Обработать события подключения, отключения, ошибки
- Реализовать отправку сообщений серверу
- Реализовать приём сообщений от сервера

### 3.4 Протокол на клиенте

- Подключить те же FlatBuffers-схемы, что и на сервере
- Реализовать сериализацию сообщений ввода
- Реализовать десериализацию снимков от сервера
- Обработать handshake с сервером
- Добавить метрики: пинг, потеря пакетов

### 3.5 Локальное состояние мира

- Создать клиентский registry для ECS
- Реализовать применение снимков от сервера к локальному состоянию
- Обработать создание и удаление сущностей по данным от сервера
- Синхронизировать компоненты с серверными данными
- Добавить логирование изменений состояния

### 3.6 Обработка ввода

- Реализовать захват ввода с клавиатуры и мыши через SDL2
- Создать абстрактный слой ввода (действия, а не кнопки)
- Добавить конфигурируемые привязки клавиш
- Реализовать формирование сообщения ввода
- Отправлять ввод на сервер с заданной частотой

### 3.7 Интерполяция

- Буферизировать последние N снимков от сервера
- Реализовать интерполяцию позиций между снимками
- Добавить настраиваемую задержку интерполяции
- Обработать пропуски снимков
- Визуализировать состояние интерполяции для отладки

**Результат фазы:** клиент подключается к серверу, отправляет ввод, получает состояние мира, интерполирует позиции. Пока без графики — только логика и логи.

---

## Фаза 4: Базовый рендеринг

**Цель:** клиент отображает мир на экране.

**Длительность:** 4-5 недель

### 4.1 Инициализация Vulkan

- Создать Vulkan instance с валидационными слоями
- Выбрать физическое устройство (GPU)
- Создать логическое устройство с нужными очередями
- Создать surface для окна SDL2
- Настроить swapchain

### 4.2 Рендер-пайплайн

- Создать базовый вершинный и фрагментный шейдеры
- Реализовать загрузку и компиляцию шейдеров
- Создать graphics pipeline для базового рендеринга
- Настроить render pass
- Реализовать command buffer для кадра

### 4.3 Абстракция рендеринга

- Создать класс Renderer как обёртку над Vulkan
- Реализовать интерфейс для отрисовки примитивов
- Добавить управление ресурсами (буферы, текстуры)
- Создать систему материалов
- Изолировать Vulkan-специфичный код от остального клиента

### 4.4 Загрузка мешей

- Определить формат хранения мешей
- Реализовать загрузку вершинных данных
- Создать vertex buffer и index buffer
- Добавить кэширование загруженных мешей
- Создать тестовые примитивы (куб, плоскость)

### 4.5 Загрузка текстур

- Интегрировать stb_image
- Реализовать загрузку изображений с диска
- Создать Vulkan image и image view
- Настроить sampler
- Добавить кэширование текстур

### 4.6 Камера

- Создать класс Camera с позицией и ориентацией
- Реализовать матрицы view и projection
- Добавить управление камерой от первого/третьего лица
- Связать камеру с сущностью игрока
- Передать матрицы в шейдер через uniform buffer

### 4.7 Система рендеринга

- Создать RenderSystem в ECS
- Добавить компонент Renderable (меш, материал)
- Реализовать сбор видимых объектов
- Отрисовать объекты с их transform'ами
- Реализовать базовый frustum culling

### 4.8 Освещение

- Добавить поддержку точечных источников света
- Реализовать простое диффузное освещение в шейдере
- Создать компонент Light
- Передать данные об источниках в шейдер
- Ограничить количество источников на сцене

**Результат фазы:** клиент отображает 3D-сцену с объектами, текстурами, освещением. Можно видеть мир, полученный от сервера.

---

## Фаза 5: PSX-стилизация

**Цель:** реализовать визуальный стиль PlayStation 1.

**Длительность:** 2-3 недели

### 5.1 Вершинный snap

- Модифицировать вершинный шейдер для округления позиций
- Реализовать настраиваемую «сетку» для snap'а
- Добавить характерное «дрожание» вершин
- Тестировать на разных расстояниях от камеры

### 5.2 Аффинное текстурирование

- Отключить перспективную коррекцию UV в шейдере
- Реализовать аффинный маппинг текстур
- Добавить настройку интенсивности эффекта
- Проверить на наклонных поверхностях

### 5.3 Ограниченная палитра

- Создать постобработку для квантизации цветов
- Реализовать дизеринг (ordered dithering)
- Добавить настраиваемую палитру
- Опционально: эффект scanlines

### 5.4 Туман и дальность прорисовки

- Реализовать вертексный туман с жёсткой границей
- Добавить отсечение объектов за пределами дальности
- Настроить параметры тумана для эстетики
- Связать дальность прорисовки с игровым состоянием

### 5.5 Разрешение рендеринга

- Добавить рендеринг в текстуру с низким разрешением
- Масштабировать на экран без фильтрации (nearest neighbor)
- Сделать внутреннее разрешение настраиваемым
- Сохранить UI в полном разрешении

**Результат фазы:** графика имеет характерный PSX-стиль — низкое разрешение, дрожащие вершины, плавающие текстуры, туман.

---

## Фаза 6: Физика и коллизии

**Цель:** сервер обрабатывает физику и коллизии, клиент отображает результат.

**Длительность:** 3-4 недели

### 6.1 Интеграция физического движка

- Добавить Jolt Physics в зависимости
- Создать обёртку для инициализации и обновления
- Настроить физический мир с гравитацией
- Определить масштаб и единицы измерения

### 6.2 Физические тела

- Создать компонент PhysicsBody
- Реализовать синхронизацию Transform с физическим телом
- Добавить типы тел: static, dynamic, kinematic
- Определить collision shapes: box, sphere, capsule, mesh
- Связать создание/удаление сущностей с физическим миром

### 6.3 Система физики

- Создать PhysicsSystem для серверного ECS
- Обновлять физический мир каждый тик
- Синхронизировать позиции после шага физики
- Обрабатывать события коллизий
- Добавить профилирование физики

### 6.4 Движение персонажа

- Создать character controller на основе Jolt
- Реализовать ходьбу по поверхности
- Добавить прыжок и гравитацию
- Обработать столкновения со стенами
- Реализовать подъём по ступеням

### 6.5 Raycast и запросы

- Реализовать raycast для определения попаданий
- Добавить shape cast для проверки проходимости
- Создать систему фильтрации по слоям
- Использовать для взаимодействия с объектами
- Использовать для AI (line of sight)

### 6.6 Триггеры

- Создать компонент TriggerVolume
- Реализовать события входа/выхода из триггера
- Добавить фильтрацию по типам сущностей
- Использовать для зон (отсеки, опасные области)

**Результат фазы:** персонажи и объекты физически корректно двигаются и сталкиваются. Можно ходить по уровню, упираться в стены, прыгать.

---

## Фаза 7: Аудиосистема

**Цель:** клиент воспроизводит пространственный звук на основе данных от сервера.

**Длительность:** 3-4 недели

### 7.1 Интеграция аудио-библиотеки

- Добавить miniaudio в зависимости
- Создать обёртку для инициализации и shutdown
- Настроить аудио-устройство
- Реализовать базовое воспроизведение звука

### 7.2 Загрузка звуков

- Определить форматы звуковых файлов (WAV, OGG)
- Реализовать загрузку и декодирование
- Создать менеджер звуковых ресурсов
- Добавить потоковое воспроизведение для длинных треков

### 7.3 Звуковые события

- Определить протокол звуковых событий от сервера
- Реализовать приём событий клиентом
- Воспроизвести звук по событию
- Добавить параметры: громкость, позиция, приоритет

### 7.4 Пространственный звук

- Интегрировать HRTF для 3D-позиционирования
- Связать позицию listener'а с камерой
- Реализовать затухание по расстоянию
- Добавить доплеровский эффект для движущихся источников

### 7.5 Окклюзия звука

- Получать данные о преградах от сервера
- Применять low-pass фильтр для звуков за стенами
- Настроить параметры окклюзии для разных материалов
- Добавить реверберацию для помещений

### 7.6 Эмбиент

- Реализовать систему фоновых звуков
- Связать эмбиент с отсеками/зонами
- Добавить плавные переходы между зонами
- Создать слой для корабельных систем (гул, вентиляция)

**Результат фазы:** звук воспроизводится пространственно, создаёт атмосферу. Слышно где находятся другие игроки и объекты.

---

## Фаза 8: Голосовая связь

**Цель:** игроки могут общаться голосом через сервер.

**Длительность:** 2-3 недели

### 8.1 Захват голоса

- Реализовать захват с микрофона через miniaudio
- Добавить Voice Activity Detection (VAD)
- Настроить буферизацию аудио-данных
- Реализовать push-to-talk как альтернативу VAD

### 8.2 Кодирование

- Интегрировать Opus кодек
- Реализовать кодирование аудио-буферов
- Настроить битрейт и качество
- Упаковать закодированные данные для отправки

### 8.3 Сетевая передача

- Определить формат голосовых пакетов
- Отправлять голос на сервер
- Принимать голос других игроков от сервера
- Обработать потерю пакетов и jitter

### 8.4 Серверная маршрутизация

- Принять голосовые пакеты от клиентов
- Определить получателей на основе пространственной модели
- Переслать пакеты нужным клиентам
- Добавить метаданные (источник, позиция)

### 8.5 Воспроизведение голоса

- Декодировать входящие пакеты
- Реализовать jitter buffer для плавности
- Применить пространственное позиционирование
- Добавить индикацию говорящего игрока

### 8.6 Эффекты голоса

- Получать параметры эффектов от сервера
- Применять искажение для рации
- Добавить шумы и помехи
- Реализовать затухание по расстоянию

**Результат фазы:** игроки слышат друг друга в игре. Голос звучит пространственно и может иметь эффекты.

---

## Фаза 9: Пользовательский интерфейс

**Цель:** клиент отображает интерфейс на основе данных от сервера.

**Длительность:** 3-4 недели

### 9.1 Интеграция ImGui

- Добавить Dear ImGui в зависимости
- Интегрировать с Vulkan рендерером
- Интегрировать с SDL2 для ввода
- Настроить стиль для игры

### 9.2 HUD

- Создать систему отображения HUD-элементов
- Отобразить здоровье и базовые параметры
- Добавить индикатор цели/взаимодействия
- Реализовать получение данных HUD от сервера

### 9.3 Меню

- Создать главное меню
- Реализовать меню паузы
- Добавить меню настроек (графика, звук, управление)
- Реализовать подключение к серверу через UI

### 9.4 Инвентарь

- Создать базовый UI инвентаря
- Отобразить список предметов
- Реализовать взаимодействие с предметами
- Связать с серверными командами

### 9.5 Диалоги и уведомления

- Создать систему всплывающих сообщений
- Реализовать журнал событий
- Добавить подтверждения действий
- Отображать системные сообщения от сервера

### 9.6 Отладочный UI

- Создать панель с метриками (FPS, пинг, тикрейт)
- Добавить консоль для команд
- Реализовать инспектор сущностей
- Добавить визуализацию сетевого трафика

**Результат фазы:** игрок видит интерфейс — HUD, меню, инвентарь. Может настраивать игру и взаимодействовать через UI.

---

## Фаза 10: Система взаимодействий

**Цель:** игроки могут взаимодействовать с объектами в мире.

**Длительность:** 3-4 недели

### 10.1 Система взаимодействий на сервере

- Создать компонент Interactable
- Определить типы взаимодействий (use, pick up, examine)
- Реализовать проверку возможности взаимодействия (расстояние, угол)
- Обработать команду взаимодействия от клиента
- Выполнить действие и отправить результат

### 10.2 Взаимодействие на клиенте

- Определить объект под прицелом (raycast)
- Показать подсказку о возможном действии
- Отправить команду взаимодействия по нажатию
- Показать результат взаимодействия

### 10.3 Подбор предметов

- Реализовать перемещение предмета в инвентарь
- Обновить визуальное состояние мира
- Синхронизировать инвентарь с клиентом
- Обработать невозможность подбора (инвентарь полон)

### 10.4 Использование объектов

- Реализовать механику дверей (открыть/закрыть)
- Реализовать механику переключателей
- Реализовать механику терминалов (открыть интерфейс)
- Добавить блокировки и условия

### 10.5 Контейнеры

- Создать систему контейнеров
- Реализовать интерфейс передачи предметов
- Синхронизировать содержимое контейнеров
- Обработать одновременный доступ нескольких игроков

**Результат фазы:** игроки могут взаимодействовать с миром — открывать двери, подбирать предметы, использовать объекты.

---

## Фаза 11: Сохранение и загрузка

**Цель:** сервер может сохранять и загружать состояние мира.

**Длительность:** 2-3 недели

### 11.1 Сериализация мира

- Расширить FlatBuffers-схемы для всех компонентов
- Реализовать полную сериализацию состояния мира
- Включить все сущности и их компоненты
- Сохранить глобальное состояние (время, события)

### 11.2 Запись в файл

- Определить формат файла сохранения
- Реализовать запись сериализованного состояния
- Добавить сжатие (lz4)
- Добавить контрольную сумму для проверки целостности

### 11.3 Загрузка из файла

- Реализовать чтение файла сохранения
- Десериализовать состояние мира
- Восстановить все сущности и компоненты
- Проверить целостность при загрузке

### 11.4 Автосохранение

- Реализовать периодическое автосохранение
- Сохранять в отдельные слоты с ротацией
- Не блокировать игровой цикл (асинхронная запись)
- Сохранять при критических событиях

### 11.5 Совместимость версий

- Добавить версию в файл сохранения
- Реализовать миграцию старых сохранений
- Обработать несовместимые версии
- Логировать изменения формата

**Результат фазы:** игровую сессию можно сохранить и продолжить позже.

---

## Фаза 12: Инструменты разработки

**Цель:** создать инструменты для разработки контента и отладки.

**Длительность:** 3-4 недели

### 12.1 Серверная консоль

- Реализовать командный интерфейс для сервера
- Добавить команды: спавн, телепорт, изменение параметров
- Реализовать автодополнение команд
- Добавить историю команд

### 12.2 Визуализатор состояния

- Создать отдельное приложение или режим клиента
- Отображать полное состояние мира без фильтрации
- Визуализировать AI, навигацию, физику
- Добавить инспектор отдельных сущностей

### 12.3 Запись и воспроизведение

- Записывать ввод всех игроков с временными метками
- Записывать seed и начальное состояние
- Воспроизводить записанную сессию детерминированно
- Использовать для отладки и регрессионного тестирования

### 12.4 Профилировщик

- Интегрировать Tracy для профилирования
- Добавить метки для всех подсистем
- Отслеживать время каждой системы
- Отслеживать память и аллокации

### 12.5 Редактор уровней (базовый)

- Создать простой редактор для размещения объектов
- Реализовать экспорт в формат, понятный серверу
- Добавить базовые инструменты (перемещение, вращение, масштаб)
- Предпросмотр в стиле игры

**Результат фазы:** есть инструменты для разработки, отладки и профилирования.

---

## Фаза 13: Тестовая сцена

**Цель:** создать тестовое окружение для проверки всех систем.

**Длительность:** 1-2 недели

### 13.1 Геометрия тестового уровня

- Создать простую карту с несколькими помещениями
- Добавить коридоры и двери между ними
- Разместить лестницы и разные уровни высоты
- Добавить коллизии для всей геометрии

### 13.2 Интерактивные объекты

- Разместить двери с механикой открытия
- Добавить предметы для подбора
- Разместить переключатели и терминалы
- Добавить контейнеры с содержимым

### 13.3 Точки спавна

- Определить точки появления игроков
- Добавить несколько точек для тестирования
- Реализовать выбор свободной точки

### 13.4 Освещение и звук

- Настроить освещение для атмосферы
- Разместить источники звука
- Добавить зоны с разным эмбиентом

### 13.5 Интеграционное тестирование

- Запустить сервер с тестовой сценой
- Подключить несколько клиентов
- Проверить все базовые механики
- Документировать найденные проблемы

**Результат фазы:** есть тестовый уровень, на котором можно проверить работу всех систем движка.

---

## Фаза 14: Стабилизация и полировка

**Цель:** исправить баги, улучшить производительность, подготовить движок к разработке игры.

**Длительность:** 2-3 недели

### 14.1 Bug fixing

- Пройти по всем известным проблемам
- Исправить критические баги
- Улучшить обработку краевых случаев
- Добавить недостающие проверки

### 14.2 Оптимизация производительности

- Профилировать сервер под нагрузкой
- Профилировать клиент
- Оптимизировать узкие места
- Проверить целевые показатели (тикрейт, FPS)

### 14.3 Обработка ошибок

- Улучшить сообщения об ошибках
- Добавить graceful degradation где возможно
- Обработать потерю соединения
- Добавить автоматическое переподключение

### 14.4 Документация

- Документировать архитектуру движка
- Описать API основных систем
- Создать руководство по добавлению контента
- Обновить README

### 14.5 Финальное тестирование

- Провести полный цикл тестирования
- Тестировать на разных конфигурациях
- Нагрузочное тестирование сервера
- Подтвердить готовность к следующей фазе

**Результат фазы:** движок стабилен, задокументирован и готов к разработке игрового контента.

---

## Критерии завершения

Движок считается готовым, когда выполнены все следующие условия:

**Сервер:**
- [ ] Стабильно работает с 12+ подключёнными клиентами
- [ ] Поддерживает 60 тиков в секунду без просадок
- [ ] Корректно обрабатывает подключение/отключение клиентов
- [ ] Сохраняет и загружает состояние мира
- [ ] Валидирует весь ввод от клиентов

**Клиент:**
- [ ] Стабильно держит 60 FPS
- [ ] Корректно интерполирует состояние между снимками
- [ ] Отображает PSX-стилизованную графику
- [ ] Воспроизводит пространственный звук
- [ ] Позволяет голосовое общение

**Сеть:**
- [ ] Дельта-компрессия снижает трафик
- [ ] Корректно обрабатывает потерю пакетов
- [ ] Работает с пингом до 200мс
- [ ] Автоматически переподключается

**Инструменты:**
- [ ] Серверная консоль работает
- [ ] Профилировщик интегрирован
- [ ] Запись/воспроизведение функционирует
- [ ] Базовый редактор позволяет создавать сцены

**Качество:**
- [ ] Нет известных критических багов
- [ ] Тесты покрывают основные системы
- [ ] CI/CD работает и блокирует плохой код
- [ ] Документация актуальна

---

## После завершения

Когда движок готов, начинается разработка самой игры:

- Система отсеков и атмосферы
- Медицинская система
- Инженерные системы корабля
- AI существ
- Процедурная генерация
- Роли и специализации
- Инструменты ГеймМастера
- Контент и баланс

Эти задачи выходят за рамки данного roadmap и будут описаны в отдельном документе.
